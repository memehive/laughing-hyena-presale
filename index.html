<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laughing Hyena Presale</title>
  <!-- Roboto Mono for all text -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
  
  <!-- ethers.js Library (UMD build) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Coinbase Wallet SDK -->
  <script src="https://unpkg.com/@coinbase/wallet-sdk/dist/wallet-sdk.umd.min.js"></script>
  <!-- Web3Modal (v1) -->
  <script src="https://unpkg.com/web3modal@1.9.8/dist/index.js"></script>
  <!-- WalletConnect Provider -->
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.7.8/dist/umd/index.min.js"></script>
  <!-- web3 Library -->
  <script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
  
  <style>
    /* (Your existing styles remain unchanged) */
    /* ... */
  </style>
</head>
<body>
  <div class="wrapper">
    <!-- Header Section -->
    <header class="container">
      <div class="inner-header">
        <img src="https://gateway.pinata.cloud/ipfs/bafybeifvoit5z7zcwgqgkd5mf65gvktzstdsztbavsvm5x3alliyfugrwu" alt="Laughing Hyena Logo" />
        <h1 class="header-title">Laughing Hyena - $LHyena Presale</h1>
      </div>
    </header>
    
    <!-- Main Content -->
    <div class="container">
      <!-- (Content omitted for brevity; same as before) -->
      <!-- ... -->
      
      <div class="wallet-buttons-container">
        <!-- Dedicated MetaMask Button -->
        <button id="connectMetaMask" class="wallet-button" onclick="connectMetaMask()" aria-label="Connect MetaMask Wallet">
          <img src="https://metamask.io/assets/icon.svg" alt="MetaMask Logo" width="24" height="24">MetaMask
        </button>
        <!-- Dedicated WalletConnect Button -->
        <button id="connectWallet" class="wallet-button" onclick="connectWalletConnect()" aria-label="Connect via WalletConnect">
          <img src="https://gateway.pinata.cloud/ipfs/bafkreica2kla4alapcinmznch47tssr2g26dpdtb3u6ltv3gzlwzmchl4a" alt="WalletConnect Logo" width="24" height="24">WalletConnect
        </button>
        <!-- Dedicated Disconnect Button -->
        <button id="disconnectWallet" class="wallet-button" onclick="disconnectWallet()" aria-label="Disconnect Wallet">
          <img src="https://gateway.pinata.cloud/ipfs/bafkreihrxilkswryoesmiwmwwlwvpcso3gtsenstcufxcwwdoq3m2yd7vm" alt="Disconnect Logo" width="24" height="24">Disconnect
        </button>
      </div>
      
      <!-- (Rest of content, buy tokens section, footer, etc.) -->
      <!-- ... -->
      
    </div>
    
    <!-- Footer (same as before) -->
    <!-- ... -->
  </div>
  
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const ethers = window.ethers;
      
      // Configuration Constants
      const BASE_CHAIN_ID_DEC = 8453;
      const BASE_CHAIN_ID_HEX = '0x2105';
      const BASECHAIN_RPC_URL = "https://base-mainnet.infura.io/v3/e923b24ca7eb4da7aa7e827ccae39ef9";
      const PRESALE_CONTRACT_ADDRESS = "0xc9beD6d7ecb7A1ea7F064A41971549FC4ee6CD20";
      const TOKEN_RATE = 20000000;
      
      // Global Variables
      let provider, signer;
      let walletConnectProvider;
      let userAddress = "";
      let isMetaMaskConnecting = false;
      
      // Web3Modal Setup for WalletConnect (disable injected so MetaMask doesn't show in modal)
      const providerOptions = {
        walletconnect: {
          package: WalletConnectProvider.default,
          options: {
            rpc: { [BASE_CHAIN_ID_DEC]: BASECHAIN_RPC_URL },
            bridge: "https://bridge.walletconnect.org",
            qrcode: true
          }
        }
      };
      
      const web3Modal = new window.Web3Modal.default({
        cacheProvider: false,
        providerOptions,
        disableInjectedProvider: true
      });
      
      // UI Helper
      function updateStatus(message) {
        document.getElementById("status").innerText = message;
      }
      
      // Wallet Event Listeners
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', (accounts) => {
          if (accounts.length > 0) {
            userAddress = accounts[0];
            updateStatus("Connected: " + userAddress);
            fetchWalletBalance();
          } else {
            userAddress = "";
            updateStatus("Not connected");
            document.getElementById("walletBalance").innerText = "Wallet Balance: 0 ETH";
          }
        });
        window.ethereum.on('chainChanged', (chainId) => {
          window.location.reload();
        });
      }
      
      // MetaMask Connection Function
      async function connectMetaMask() {
        if (isMetaMaskConnecting) {
          alert("A connection request is already pending. Please wait.");
          return;
        }
        isMetaMaskConnecting = true;
        
        if (window.ethereum && window.ethereum.isMetaMask) {
          // Optional: Check if Exodus is installed
          if (window.ethereum.isExodus) {
            alert("It appears that Exodus wallet is installed. For a MetaMask connection, please disable Exodus or install MetaMask.");
            isMetaMaskConnecting = false;
            return;
          }
          try {
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            if (accounts.length === 0) {
              updateStatus("No accounts found.");
              isMetaMaskConnecting = false;
              return;
            }
            let tempProvider = new ethers.providers.Web3Provider(window.ethereum);
            const network = await tempProvider.getNetwork();
            if (network.chainId !== BASE_CHAIN_ID_DEC) {
              try {
                await window.ethereum.request({
                  method: 'wallet_switchEthereumChain',
                  params: [{ chainId: BASE_CHAIN_ID_HEX }],
                });
                tempProvider = new ethers.providers.Web3Provider(window.ethereum);
              } catch (switchError) {
                updateStatus("Please switch your MetaMask to the Base network.");
                isMetaMaskConnecting = false;
                return;
              }
            }
            provider = tempProvider;
            signer = provider.getSigner();
            userAddress = accounts[0];
            updateStatus("Connected to MetaMask on Base network: " + userAddress);
            fetchWalletBalance();
          } catch (error) {
            updateStatus("MetaMask connection failed: " + error.message);
          } finally {
            isMetaMaskConnecting = false;
          }
        } else {
          updateStatus("MetaMask not detected. Please install MetaMask.");
          isMetaMaskConnecting = false;
        }
      }
      
      // WalletConnect Connection Function
      async function connectWalletConnect() {
        try {
          const instance = await web3Modal.connect();
          provider = new ethers.providers.Web3Provider(instance);
          const network = await provider.getNetwork();
          if (network.chainId !== BASE_CHAIN_ID_DEC) {
            updateStatus("Please connect to Basechain using your selected wallet.");
            return;
          }
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          updateStatus("Connected with WalletConnect on Basechain: " + userAddress);
          fetchWalletBalance();
        } catch (error) {
          updateStatus("WalletConnect connection failed: " + error.message);
        }
      }
      
      async function disconnectWallet() {
        if (!provider || userAddress === "") {
          alert("No wallet connected");
          return;
        }
        if (walletConnectProvider && walletConnectProvider.disconnect) {
          await walletConnectProvider.disconnect();
        }
        provider = null;
        signer = null;
        userAddress = "";
        updateStatus("Not connected");
        document.getElementById("walletBalance").innerText = "Wallet Balance: 0 ETH";
      }
      
      // Helper to Fetch Wallet ETH Balance
      async function fetchWalletBalance() {
        if (!provider || !userAddress) return;
        try {
          const balance = await provider.getBalance(userAddress);
          const balanceFormatted = ethers.utils.formatEther(balance);
          document.getElementById("walletBalance").innerText = "Wallet Balance: " + balanceFormatted + " ETH";
        } catch (err) {
          console.error("Error fetching wallet balance:", err);
        }
      }
      
      setInterval(fetchWalletBalance, 10000);
      
      function promptBuyTokens() {
        if (!signer) {
          alert("Please connect your wallet first!");
          updateStatus("Please connect your wallet first!");
          return;
        }
        validateEthAmount();
        const ethAmount = parseFloat(document.getElementById("ethAmount").value);
        if (!ethAmount || ethAmount < 0.1 || ethAmount > 5) {
          updateStatus("Contribution must be between 0.1 and 5 ETH.");
          return;
        }
        const tokenAmount = (ethAmount * TOKEN_RATE).toLocaleString();
        document.getElementById("transactionSummary").innerText =
          `You are about to contribute ${ethAmount} ETH to receive ${tokenAmount} LHyena tokens.`;
        document.getElementById("confirmationModal").style.display = "flex";
      }
      
      function closeModal() {
        document.getElementById("confirmationModal").style.display = "none";
      }
      
      async function confirmedBuyTokens() {
        closeModal();
        const network = await provider.getNetwork();
        if (network.chainId !== BASE_CHAIN_ID_DEC) {
          updateStatus("Incorrect network. Please switch to Basechain.");
          return;
        }
        buyTokens();
      }
      
      async function buyTokens() {
        if (!signer) {
          alert("Please connect your wallet first!");
          updateStatus("Please connect your wallet first!");
          return;
        }
        let ethAmount = parseFloat(document.getElementById("ethAmount").value);
        if (ethAmount < 0.1 || ethAmount > 5) {
          updateStatus("Contribution must be between 0.1 and 5 ETH.");
          return;
        }
        const contract = new ethers.Contract(
          PRESALE_CONTRACT_ADDRESS,
          [{
            "inputs": [],
            "name": "buyTokens",
            "outputs": [],
            "stateMutability": "payable",
            "type": "function"
          }],
          signer
        );
        try {
          const tx = await contract.buyTokens({ value: ethers.utils.parseEther(ethAmount.toString()) });
          updateStatus("Transaction submitted. Waiting for 3 confirmations...");
          await tx.wait(3);
          updateStatus("Transaction Successful! You have purchased $LHyena tokens.");
        } catch (error) {
          updateStatus("Transaction failed: " + error.message);
        }
      }
      
      function validateEthAmount() {
        const ethInput = document.getElementById("ethAmount");
        let ethAmount = parseFloat(ethInput.value);
        if (isNaN(ethAmount)) {
          updateStatus("Please enter a valid ETH amount.");
          return;
        }
        if (ethAmount > 5) {
          alert("Maximum contribution per wallet is 5 ETH");
          ethInput.value = 5;
          updateStatus("Maximum contribution per wallet is 5 ETH");
        } else if (ethAmount < 0.1 && ethInput.value !== "") {
          alert("Minimum contribution is 0.1 ETH");
          ethInput.value = 0.1;
          updateStatus("Minimum contribution is 0.1 ETH");
        } else {
          updateStatus("");
        }
      }
      
      function calculateTokens() {
        let ethAmount = parseFloat(document.getElementById("ethAmount").value) || 0;
        document.getElementById("tokenAmount").innerText = (ethAmount * TOKEN_RATE).toLocaleString();
      }
      
      async function fetchPresaleProgress() {
        if (!provider) return;
        try {
          const contract = new ethers.Contract(
            PRESALE_CONTRACT_ADDRESS,
            [{
              "inputs": [],
              "name": "totalRaised",
              "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
              "stateMutability": "view",
              "type": "function"
            }],
            provider
          );
          const ethRaised = await contract.totalRaised();
          const ethRaisedFormatted = ethers.utils.formatEther(ethRaised);
          updateProgressBar(ethRaisedFormatted);
          document.getElementById("ethRaised").innerText = ethRaisedFormatted;
        } catch (error) {
          console.error("Error fetching presale progress:", error);
        }
      }
      
      function updateProgressBar(ethRaised) {
        const hardCap = 50;
        const progress = Math.min((ethRaised / hardCap) * 100, 100);
        const progressBar = document.getElementById("progress-bar");
        progressBar.style.width = progress + '%';
        progressBar.innerText = Math.round(progress) + '%';
      }
      
      setInterval(fetchPresaleProgress, 5000);
      
      // Copy function for the contract address
      function copyContractAddress() {
        const addressText = "0xc9beD6d7ecb7A1ea7F064A41971549FC4ee6CD20";
        if (navigator.clipboard) {
          navigator.clipboard.writeText(addressText).then(() => {
            alert("Contract address copied to clipboard!");
          }).catch(() => {
            alert("Failed to copy contract address. Please try again.");
          });
        } else {
          const textArea = document.createElement("textarea");
          textArea.value = addressText;
          document.body.appendChild(textArea);
          textArea.select();
          try {
            document.execCommand("copy");
            alert("Contract address copied to clipboard!");
          } catch (err) {
            alert("Failed to copy contract address. Please try again.");
          }
          document.body.removeChild(textArea);
        }
      }
      
      // Expose functions for button clicks
      window.connectMetaMask = connectMetaMask;
      window.connectWalletConnect = connectWalletConnect;
      window.disconnectWallet = disconnectWallet;
      window.promptBuyTokens = promptBuyTokens;
      window.closeModal = closeModal;
      window.confirmedBuyTokens = confirmedBuyTokens;
      window.validateEthAmount = validateEthAmount;
      window.calculateTokens = calculateTokens;
      window.copyContractAddress = copyContractAddress;
    });
  </script>
</body>
</html>
